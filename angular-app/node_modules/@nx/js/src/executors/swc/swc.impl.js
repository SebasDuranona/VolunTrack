"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.swcExecutor = void 0;
const devkit_1 = require("@nx/devkit");
const assets_1 = require("../../utils/assets/assets");
const fs_extra_1 = require("fs-extra");
const fast_glob_1 = require("fast-glob");
const path_1 = require("path");
const assets_2 = require("../../utils/assets");
const check_dependencies_1 = require("../../utils/check-dependencies");
const compiler_helper_dependency_1 = require("../../utils/compiler-helper-dependency");
const inline_1 = require("../../utils/inline");
const package_json_1 = require("../../utils/package-json");
const compile_swc_1 = require("../../utils/swc/compile-swc");
const get_swcrc_path_1 = require("../../utils/swc/get-swcrc-path");
const inline_2 = require("../../utils/swc/inline");
function normalizeOptions(options, root, sourceRoot, projectRoot) {
    const outputPath = (0, path_1.join)(root, options.outputPath);
    if (options.skipTypeCheck == null) {
        options.skipTypeCheck = false;
    }
    if (options.watch == null) {
        options.watch = false;
    }
    // TODO: put back when inlining story is more stable
    // if (options.external == null) {
    //   options.external = 'all';
    // } else if (Array.isArray(options.external) && options.external.length === 0) {
    //   options.external = 'none';
    // }
    if (Array.isArray(options.external) && options.external.length > 0) {
        const firstItem = options.external[0];
        if (firstItem === 'all' || firstItem === 'none') {
            options.external = firstItem;
        }
    }
    const files = (0, assets_1.assetGlobsToFiles)(options.assets, root, outputPath);
    const projectRootParts = projectRoot.split('/');
    // We pop the last part of the `projectRoot` to pass
    // the last part (projectDir) and the remainder (projectRootParts) to swc
    const projectDir = projectRootParts.pop();
    // default to current directory if projectRootParts is [].
    // Eg: when a project is at the root level, outside of layout dir
    const swcCwd = projectRootParts.join('/') || '.';
    const { swcrcPath, tmpSwcrcPath } = (0, get_swcrc_path_1.getSwcrcPath)(options, root, projectRoot);
    const swcCliOptions = {
        srcPath: projectDir,
        destPath: (0, path_1.relative)((0, path_1.join)(root, swcCwd), outputPath),
        swcCwd,
        swcrcPath,
    };
    return {
        ...options,
        mainOutputPath: (0, path_1.resolve)(outputPath, options.main.replace(`${projectRoot}/`, '').replace('.ts', '.js')),
        files,
        root,
        sourceRoot,
        projectRoot,
        originalProjectRoot: projectRoot,
        outputPath,
        tsConfig: (0, path_1.join)(root, options.tsConfig),
        swcCliOptions,
        tmpSwcrcPath,
    };
}
async function* swcExecutor(_options, context) {
    const { sourceRoot, root } = context.projectsConfigurations.projects[context.projectName];
    const options = normalizeOptions(_options, context.root, sourceRoot, root);
    const { tmpTsConfig, dependencies } = (0, check_dependencies_1.checkDependencies)(context, options.tsConfig);
    if (tmpTsConfig) {
        options.tsConfig = tmpTsConfig;
    }
    const swcHelperDependency = (0, compiler_helper_dependency_1.getHelperDependency)(compiler_helper_dependency_1.HelperDependency.swc, options.swcCliOptions.swcrcPath, dependencies, context.projectGraph);
    if (swcHelperDependency) {
        dependencies.push(swcHelperDependency);
    }
    const inlineProjectGraph = (0, inline_1.handleInliningBuild)(context, options, options.tsConfig);
    if (!(0, inline_1.isInlineGraphEmpty)(inlineProjectGraph)) {
        options.projectRoot = '.'; // set to root of workspace to include other libs for type check
        // remap paths for SWC compilation
        options.swcCliOptions.srcPath = options.swcCliOptions.swcCwd;
        options.swcCliOptions.swcCwd = '.';
        options.swcCliOptions.destPath = (0, path_1.join)(options.swcCliOptions.destPath.split((0, path_1.normalize)('../')).at(-1), options.swcCliOptions.srcPath);
        // tmp swcrc with dependencies to exclude
        // - buildable libraries
        // - other libraries that are not dependent on the current project
        options.swcCliOptions.swcrcPath = (0, inline_2.generateTmpSwcrc)(inlineProjectGraph, options.swcCliOptions.swcrcPath, options.tmpSwcrcPath);
    }
    function determineModuleFormatFromSwcrc(absolutePathToSwcrc) {
        const swcrc = (0, devkit_1.readJsonFile)(absolutePathToSwcrc);
        return swcrc.module?.type?.startsWith('es') ? 'esm' : 'cjs';
    }
    if (options.watch) {
        let disposeFn;
        process.on('SIGINT', () => disposeFn());
        process.on('SIGTERM', () => disposeFn());
        return yield* (0, compile_swc_1.compileSwcWatch)(context, options, async () => {
            const assetResult = await (0, assets_2.copyAssets)(options, context);
            const packageJsonResult = await (0, package_json_1.copyPackageJson)({
                ...options,
                additionalEntryPoints: createEntryPoints(options, context),
                format: [
                    determineModuleFormatFromSwcrc(options.swcCliOptions.swcrcPath),
                ],
                // As long as d.ts files match their .js counterparts, we don't need to emit them.
                // TSC can match them correctly based on file names.
                skipTypings: true,
            }, context);
            removeTmpSwcrc(options.swcCliOptions.swcrcPath);
            disposeFn = () => {
                assetResult?.stop();
                packageJsonResult?.stop();
            };
        });
    }
    else {
        return yield (0, compile_swc_1.compileSwc)(context, options, async () => {
            await (0, assets_2.copyAssets)(options, context);
            await (0, package_json_1.copyPackageJson)({
                ...options,
                additionalEntryPoints: createEntryPoints(options, context),
                format: [
                    determineModuleFormatFromSwcrc(options.swcCliOptions.swcrcPath),
                ],
                // As long as d.ts files match their .js counterparts, we don't need to emit them.
                // TSC can match them correctly based on file names.
                skipTypings: true,
                extraDependencies: swcHelperDependency ? [swcHelperDependency] : [],
            }, context);
            removeTmpSwcrc(options.swcCliOptions.swcrcPath);
            (0, inline_1.postProcessInlinedDependencies)(options.outputPath, options.originalProjectRoot, inlineProjectGraph);
        });
    }
}
exports.swcExecutor = swcExecutor;
function removeTmpSwcrc(swcrcPath) {
    if (swcrcPath.includes((0, path_1.normalize)('tmp/')) &&
        swcrcPath.includes('.generated.swcrc')) {
        (0, fs_extra_1.removeSync)((0, path_1.dirname)(swcrcPath));
    }
}
function createEntryPoints(options, context) {
    if (!options.additionalEntryPoints?.length)
        return [];
    return (0, fast_glob_1.sync)(options.additionalEntryPoints, {
        cwd: context.root,
    });
}
exports.default = swcExecutor;
