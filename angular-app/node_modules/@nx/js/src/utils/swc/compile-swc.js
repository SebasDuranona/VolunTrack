"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileSwcWatch = exports.compileSwc = void 0;
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const print_diagnostics_1 = require("../typescript/print-diagnostics");
const run_type_check_1 = require("../typescript/run-type-check");
function getSwcCmd({ swcrcPath, srcPath, destPath }, watch = false) {
    const swcCLI = require.resolve('@swc/cli/bin/swc.js');
    let swcCmd = `node ${swcCLI} ${
    // TODO(jack): clean this up when we remove inline module support
    // Handle root project
    srcPath === '.' ? 'src' : srcPath} -d ${srcPath === '.' ? `${destPath}/src` : destPath} --config-file=${swcrcPath}`;
    return watch ? swcCmd.concat(' --watch') : swcCmd;
}
function getTypeCheckOptions(normalizedOptions) {
    const { projectRoot, watch, tsConfig, root, outputPath } = normalizedOptions;
    const typeCheckOptions = {
        mode: 'emitDeclarationOnly',
        tsConfigPath: tsConfig,
        outDir: outputPath,
        workspaceRoot: root,
        rootDir: projectRoot,
    };
    if (watch) {
        typeCheckOptions.incremental = true;
        typeCheckOptions.cacheDir = devkit_1.cacheDir;
    }
    return typeCheckOptions;
}
async function compileSwc(context, normalizedOptions, postCompilationCallback) {
    devkit_1.logger.log(`Compiling with SWC for ${context.projectName}...`);
    if (normalizedOptions.clean) {
        (0, fs_extra_1.removeSync)(normalizedOptions.outputPath);
    }
    const swcCmdLog = (0, child_process_1.execSync)(getSwcCmd(normalizedOptions.swcCliOptions), {
        encoding: 'utf8',
        cwd: normalizedOptions.swcCliOptions.swcCwd,
    });
    devkit_1.logger.log(swcCmdLog.replace(/\n/, ''));
    const isCompileSuccess = swcCmdLog.includes('Successfully compiled');
    if (normalizedOptions.skipTypeCheck) {
        await postCompilationCallback();
        return { success: isCompileSuccess };
    }
    const { errors, warnings } = await (0, run_type_check_1.runTypeCheck)(getTypeCheckOptions(normalizedOptions));
    const hasErrors = errors.length > 0;
    const hasWarnings = warnings.length > 0;
    if (hasErrors || hasWarnings) {
        await (0, print_diagnostics_1.printDiagnostics)(errors, warnings);
    }
    await postCompilationCallback();
    return {
        success: !hasErrors && isCompileSuccess,
        outfile: normalizedOptions.mainOutputPath,
    };
}
exports.compileSwc = compileSwc;
async function* compileSwcWatch(context, normalizedOptions, postCompilationCallback) {
    const getResult = (success) => ({
        success,
        outfile: normalizedOptions.mainOutputPath,
    });
    let typeCheckOptions;
    let initialPostCompile = true;
    if (normalizedOptions.clean) {
        (0, fs_extra_1.removeSync)(normalizedOptions.outputPath);
    }
    return yield* (0, async_iterable_1.createAsyncIterable)(async ({ next, done }) => {
        let processOnExit;
        let stdoutOnData;
        let stderrOnData;
        let watcherOnExit;
        const swcWatcher = (0, child_process_1.exec)(getSwcCmd(normalizedOptions.swcCliOptions, true), { cwd: normalizedOptions.swcCliOptions.swcCwd });
        processOnExit = () => {
            swcWatcher.kill();
            done();
            process.off('SIGINT', processOnExit);
            process.off('SIGTERM', processOnExit);
            process.off('exit', processOnExit);
        };
        stdoutOnData = async (data) => {
            process.stdout.write(data);
            if (!data.startsWith('Watching')) {
                const swcStatus = data.includes('Successfully');
                if (initialPostCompile) {
                    await postCompilationCallback();
                    initialPostCompile = false;
                }
                if (normalizedOptions.skipTypeCheck) {
                    next(getResult(swcStatus));
                    return;
                }
                if (!typeCheckOptions) {
                    typeCheckOptions = getTypeCheckOptions(normalizedOptions);
                }
                const delayed = delay(5000);
                next(getResult(await Promise.race([
                    delayed
                        .start()
                        .then(() => ({ tscStatus: false, type: 'timeout' })),
                    (0, run_type_check_1.runTypeCheck)(typeCheckOptions).then(({ errors, warnings }) => {
                        const hasErrors = errors.length > 0;
                        if (hasErrors) {
                            (0, print_diagnostics_1.printDiagnostics)(errors, warnings);
                        }
                        return {
                            tscStatus: !hasErrors,
                            type: 'tsc',
                        };
                    }),
                ]).then(({ type, tscStatus }) => {
                    if (type === 'tsc') {
                        delayed.cancel();
                        return tscStatus && swcStatus;
                    }
                    return swcStatus;
                })));
            }
        };
        stderrOnData = (err) => {
            process.stderr.write(err);
            if (err.includes('Debugger attached.')) {
                return;
            }
            next(getResult(false));
        };
        watcherOnExit = () => {
            done();
            swcWatcher.off('exit', watcherOnExit);
        };
        swcWatcher.stdout.on('data', stdoutOnData);
        swcWatcher.stderr.on('data', stderrOnData);
        process.on('SIGINT', processOnExit);
        process.on('SIGTERM', processOnExit);
        process.on('exit', processOnExit);
        swcWatcher.on('exit', watcherOnExit);
    });
}
exports.compileSwcWatch = compileSwcWatch;
function delay(ms) {
    let timerId = undefined;
    return {
        start() {
            return new Promise((resolve) => {
                timerId = setTimeout(() => {
                    resolve();
                }, ms);
            });
        },
        cancel() {
            if (timerId) {
                clearTimeout(timerId);
                timerId = undefined;
            }
        },
    };
}
