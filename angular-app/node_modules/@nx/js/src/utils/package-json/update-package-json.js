"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdatedPackageJsonContent = exports.getExports = exports.updatePackageJson = void 0;
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const create_package_json_1 = require("nx/src/plugins/js/package-json/create-package-json");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const fileutils_1 = require("nx/src/utils/fileutils");
const fs_1 = require("fs");
const nx_deps_cache_1 = require("nx/src/project-graph/nx-deps-cache");
const get_main_file_dir_1 = require("../get-main-file-dir");
function updatePackageJson(options, context, target, dependencies, fileMap = null) {
    let packageJson;
    if (fileMap == null) {
        fileMap = (0, nx_deps_cache_1.readFileMapCache)()?.fileMap?.projectFileMap || {};
    }
    if (options.updateBuildableProjectDepsInPackageJson) {
        packageJson = (0, create_package_json_1.createPackageJson)(context.projectName, context.projectGraph, {
            target: context.targetName,
            root: context.root,
            // By default we remove devDependencies since this is a production build.
            isProduction: true,
        }, fileMap);
        if (options.excludeLibsInPackageJson) {
            dependencies = dependencies.filter((dep) => dep.node.type !== 'lib');
        }
        addMissingDependencies(packageJson, context, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
    else {
        const pathToPackageJson = (0, path_1.join)(context.root, options.projectRoot, 'package.json');
        packageJson = (0, fileutils_1.fileExists)(pathToPackageJson)
            ? (0, devkit_1.readJsonFile)(pathToPackageJson)
            : { name: context.projectName, version: '0.0.1' };
    }
    // update package specific settings
    packageJson = getUpdatedPackageJsonContent(packageJson, options);
    // save files
    (0, devkit_1.writeJsonFile)(`${options.outputPath}/package.json`, packageJson);
    if (options.generateLockfile) {
        const packageManager = (0, devkit_1.detectPackageManager)(context.root);
        const lockFile = (0, lock_file_1.createLockFile)(packageJson, context.projectGraph, packageManager);
        (0, fs_extra_1.writeFileSync)(`${options.outputPath}/${(0, lock_file_1.getLockFileName)(packageManager)}`, lockFile, {
            encoding: 'utf-8',
        });
    }
}
exports.updatePackageJson = updatePackageJson;
function isNpmNode(node, graph) {
    return !!(graph.externalNodes[node.name]?.type === 'npm');
}
function isWorkspaceProject(node, graph) {
    return !!graph.nodes[node.name];
}
function addMissingDependencies(packageJson, { projectName, targetName, configurationName, root, projectGraph, }, dependencies, propType = 'dependencies') {
    const workspacePackageJson = (0, devkit_1.readJsonFile)((0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, 'package.json'));
    dependencies.forEach((entry) => {
        if (isNpmNode(entry.node, projectGraph)) {
            const { packageName, version } = entry.node.data;
            if (packageJson.dependencies?.[packageName] ||
                packageJson.devDependencies?.[packageName] ||
                packageJson.peerDependencies?.[packageName]) {
                return;
            }
            if (workspacePackageJson.devDependencies?.[packageName]) {
                return;
            }
            packageJson[propType] ??= {};
            packageJson[propType][packageName] = version;
        }
        else if (isWorkspaceProject(entry.node, projectGraph)) {
            const packageName = entry.name;
            if (!!workspacePackageJson.devDependencies?.[packageName]) {
                return;
            }
            if (!packageJson.dependencies?.[packageName] &&
                !packageJson.devDependencies?.[packageName] &&
                !packageJson.peerDependencies?.[packageName]) {
                const outputs = (0, devkit_1.getOutputsForTargetAndConfiguration)({
                    project: projectName,
                    target: targetName,
                    configuration: configurationName,
                }, {}, entry.node);
                const depPackageJsonPath = (0, path_1.join)(root, outputs[0], 'package.json');
                if ((0, fs_1.existsSync)(depPackageJsonPath)) {
                    const version = (0, devkit_1.readJsonFile)(depPackageJsonPath).version;
                    packageJson[propType] ??= {};
                    packageJson[propType][packageName] = version;
                }
            }
        }
    });
}
function getExports(options) {
    const mainFile = options.outputFileName
        ? options.outputFileName.replace(/\.[tj]s$/, '')
        : (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = options.outputFileName
        ? './'
        : (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.projectRoot);
    const exports = {
        '.': relativeMainFileDir + mainFile + options.fileExt,
    };
    if (options.additionalEntryPoints) {
        const jsRegex = /\.[jt]sx?$/;
        for (const file of options.additionalEntryPoints) {
            const { ext: fileExt, name: fileName } = (0, path_1.parse)(file);
            const relativeDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(file, options.projectRoot);
            const sourceFilePath = relativeDir + fileName;
            const entryFilepath = sourceFilePath.replace(/^\.\/src\//, './');
            const isJsFile = jsRegex.test(fileExt);
            exports[isJsFile ? entryFilepath : entryFilepath + fileExt] =
                sourceFilePath + (isJsFile ? options.fileExt : fileExt);
        }
    }
    return exports;
}
exports.getExports = getExports;
function getUpdatedPackageJsonContent(packageJson, options) {
    // Default is CJS unless esm is explicitly passed.
    const hasCjsFormat = !options.format || options.format?.includes('cjs');
    const hasEsmFormat = options.format?.includes('esm');
    if (options.generateExportsField) {
        packageJson.exports =
            typeof packageJson.exports === 'string' ? {} : { ...packageJson.exports };
        packageJson.exports['./package.json'] = './package.json';
    }
    if (hasEsmFormat) {
        const esmExports = getExports({
            ...options,
            fileExt: options.outputFileExtensionForEsm ?? '.js',
        });
        packageJson.module = esmExports['.'];
        if (!hasCjsFormat) {
            packageJson.type = 'module';
            packageJson.main ??= esmExports['.'];
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(esmExports)) {
                packageJson.exports[exportEntry] = hasCjsFormat
                    ? { import: filePath }
                    : filePath;
            }
        }
    }
    // CJS output may have .cjs or .js file extensions.
    // Bundlers like rollup and esbuild supports .cjs for CJS and .js for ESM.
    // Bundlers/Compilers like webpack, tsc, swc do not have different file extensions (unless you use .mts or .cts in source).
    if (hasCjsFormat) {
        const cjsExports = getExports({
            ...options,
            fileExt: options.outputFileExtensionForCjs ?? '.js',
        });
        packageJson.main = cjsExports['.'];
        if (!hasEsmFormat) {
            packageJson.type = 'commonjs';
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(cjsExports)) {
                if (hasEsmFormat) {
                    packageJson.exports[exportEntry]['default'] ??= filePath;
                }
                else {
                    packageJson.exports[exportEntry] = filePath;
                }
            }
        }
    }
    if (!options.skipTypings) {
        const mainFile = (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
        const relativeMainFileDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.projectRoot);
        const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
        packageJson.types = packageJson.types ?? typingsFile;
    }
    return packageJson;
}
exports.getUpdatedPackageJsonContent = getUpdatedPackageJsonContent;
