"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackNxBuildCoordinationPlugin = void 0;
const child_process_1 = require("child_process");
const client_1 = require("nx/src/daemon/client/client");
const watch_1 = require("nx/src/command-line/watch");
const output_1 = require("nx/src/utils/output");
class WebpackNxBuildCoordinationPlugin {
    constructor(buildCmd, skipInitialBuild) {
        this.buildCmd = buildCmd;
        this.currentlyRunning = 'none';
        this.buildCmdProcess = null;
        if (!skipInitialBuild) {
            this.buildChangedProjects();
        }
        this.startWatchingBuildableLibs();
    }
    apply(compiler) {
        compiler.hooks.beforeCompile.tapPromise('IncrementalDevServerPlugin', async () => {
            while (this.currentlyRunning === 'nx-build') {
                await sleep(50);
            }
            this.currentlyRunning = 'webpack-build';
        });
        compiler.hooks.done.tapPromise('IncrementalDevServerPlugin', async () => {
            this.currentlyRunning = 'none';
        });
    }
    async startWatchingBuildableLibs() {
        const unregisterFileWatcher = await this.createFileWatcher();
        process.on('exit', () => {
            unregisterFileWatcher();
        });
    }
    async buildChangedProjects() {
        while (this.currentlyRunning === 'webpack-build') {
            await sleep(50);
        }
        this.currentlyRunning = 'nx-build';
        try {
            return await new Promise((res) => {
                this.buildCmdProcess = (0, child_process_1.exec)(this.buildCmd);
                this.buildCmdProcess.stdout.pipe(process.stdout);
                this.buildCmdProcess.stderr.pipe(process.stderr);
                this.buildCmdProcess.on('exit', () => {
                    res();
                });
                this.buildCmdProcess.on('error', () => {
                    res();
                });
            });
        }
        finally {
            this.currentlyRunning = 'none';
            this.buildCmdProcess = null;
        }
    }
    createFileWatcher() {
        const runner = new watch_1.BatchFunctionRunner(() => this.buildChangedProjects());
        return client_1.daemonClient.registerFileWatcher({
            watchProjects: 'all',
        }, (err, { changedProjects, changedFiles }) => {
            if (err === 'closed') {
                output_1.output.error({
                    title: 'Watch connection closed',
                    bodyLines: [
                        'The daemon has closed the connection to this watch process.',
                        'Please restart your watch command.',
                    ],
                });
                process.exit(1);
            }
            if (this.buildCmdProcess) {
                this.buildCmdProcess.kill(2);
                this.buildCmdProcess = null;
            }
            // Queue a build
            runner.enqueue(changedProjects, changedFiles);
        });
    }
}
exports.WebpackNxBuildCoordinationPlugin = WebpackNxBuildCoordinationPlugin;
function sleep(time) {
    return new Promise((resolve) => setTimeout(resolve, time));
}
