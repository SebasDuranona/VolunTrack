"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleFederationConfig = exports.getRemotes = void 0;
const devkit_1 = require("@nx/devkit");
const internal_1 = require("@nx/js/src/internal");
const find_matching_projects_1 = require("nx/src/utils/find-matching-projects");
const chalk = require("chalk");
const path_1 = require("path");
const fs_1 = require("fs");
function extractRemoteProjectsFromConfig(config, pathToManifestFile) {
    const remotes = [];
    if (pathToManifestFile && (0, fs_1.existsSync)(pathToManifestFile)) {
        const moduleFederationManifestJson = (0, fs_1.readFileSync)(pathToManifestFile, 'utf-8');
        if (moduleFederationManifestJson) {
            // This should have shape of
            // {
            //   "remoteName": "remoteLocation",
            // }
            const parsedManifest = JSON.parse(moduleFederationManifestJson);
            if (Object.keys(parsedManifest).every((key) => typeof key === 'string' && typeof parsedManifest[key] === 'string')) {
                remotes.push(...Object.keys(parsedManifest));
            }
        }
    }
    const staticRemotes = config.remotes?.map((r) => (Array.isArray(r) ? r[0] : r)) ?? [];
    remotes.push(...staticRemotes);
    return remotes;
}
function collectRemoteProjects(remote, collected, context) {
    const remoteProject = context.projectGraph.nodes[remote]?.data;
    if (!context.projectGraph.nodes[remote] || collected.has(remote)) {
        return;
    }
    collected.add(remote);
    const remoteProjectRoot = remoteProject.root;
    const remoteProjectTsConfig = remoteProject.targets['build'].options.tsConfig;
    const remoteProjectConfig = getModuleFederationConfig(remoteProjectTsConfig, context.root, remoteProjectRoot);
    const remoteProjectRemotes = extractRemoteProjectsFromConfig(remoteProjectConfig);
    remoteProjectRemotes.forEach((r) => collectRemoteProjects(r, collected, context));
}
function getRemotes(devRemotes, skipRemotes, config, context, pathToManifestFile) {
    const collectedRemotes = new Set();
    const remotes = extractRemoteProjectsFromConfig(config, pathToManifestFile);
    remotes.forEach((r) => collectRemoteProjects(r, collectedRemotes, context));
    const remotesToSkip = new Set((0, find_matching_projects_1.findMatchingProjects)(skipRemotes, context.projectGraph.nodes) ?? []);
    if (remotesToSkip.size > 0) {
        devkit_1.logger.info(`Remotes not served automatically: ${[...remotesToSkip.values()].join(', ')}`);
    }
    const knownRemotes = Array.from(collectedRemotes).filter((r) => !remotesToSkip.has(r));
    devkit_1.logger.info(`NX Starting module federation dev-server for ${chalk.bold(context.projectName)} with ${knownRemotes.length} remotes`);
    const devServeApps = new Set(!devRemotes
        ? []
        : Array.isArray(devRemotes)
            ? (0, find_matching_projects_1.findMatchingProjects)(devRemotes, context.projectGraph.nodes)
            : (0, find_matching_projects_1.findMatchingProjects)([devRemotes], context.projectGraph.nodes));
    const staticRemotes = knownRemotes.filter((r) => !devServeApps.has(r));
    const devServeRemotes = knownRemotes.filter((r) => devServeApps.has(r));
    const remotePorts = devServeRemotes.map((r) => context.projectGraph.nodes[r].data.targets['serve'].options.port);
    return {
        staticRemotes,
        devRemotes: devServeRemotes,
        remotePorts,
    };
}
exports.getRemotes = getRemotes;
function getModuleFederationConfig(tsconfigPath, workspaceRoot, projectRoot, pluginName = 'react') {
    const moduleFederationConfigPathJS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.js');
    const moduleFederationConfigPathTS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.ts');
    let moduleFederationConfigPath = moduleFederationConfigPathJS;
    // create a no-op so this can be called with issue
    const fullTSconfigPath = tsconfigPath.startsWith(workspaceRoot)
        ? tsconfigPath
        : (0, path_1.join)(workspaceRoot, tsconfigPath);
    let cleanupTranspiler = () => { };
    if ((0, fs_1.existsSync)(moduleFederationConfigPathTS)) {
        cleanupTranspiler = (0, internal_1.registerTsProject)(fullTSconfigPath);
        moduleFederationConfigPath = moduleFederationConfigPathTS;
    }
    try {
        const config = require(moduleFederationConfigPath);
        cleanupTranspiler();
        return config.default || config;
    }
    catch {
        throw new Error(`Could not load ${moduleFederationConfigPath}. Was this project generated with "@nx/${pluginName}:host"?\nSee: https://nx.dev/concepts/more-concepts/faster-builds-with-module-federation`);
    }
}
exports.getModuleFederationConfig = getModuleFederationConfig;
