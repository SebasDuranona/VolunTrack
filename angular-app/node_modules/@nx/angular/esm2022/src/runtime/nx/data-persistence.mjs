import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { isObservable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, } from 'rxjs/operators';
/**
 *
 * @whatItDoes Handles pessimistic updates (updating the server first).
 *
 * Updating the server, when implemented naively, suffers from race conditions and poor error handling.
 *
 * `pessimisticUpdate` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       pessimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           // update the backend first, and then dispatch an action that will
 *           // update the client side
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             map((updated) => ({
 *               type: 'UPDATE_TODO_SUCCESS',
 *               todo: updated,
 *             }))
 *           );
 *         },
 *         onError: (action: UpdateTodo, error: any) => {
 *           // we don't need to undo the changes on the client side.
 *           // we can dispatch an error, or simply log the error here and return `null`
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 *
 * @whatItDoes Handles optimistic updates (updating the client first).
 *
 * It runs all fetches in order, which removes race conditions and forces the developer to handle errors.
 *
 * When using `optimisticUpdate`, in case of a failure, the developer has already updated the state locally,
 * so the developer must provide an undo action.
 *
 * The error handling must be done in the callback, or by means of the undo action.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       optimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             mapTo({
 *               type: 'UPDATE_TODO_SUCCESS',
 *             })
 *           );
 *         },
 *         undoAction: (action: UpdateTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return {
 *             type: 'UNDO_TODO_UPDATE',
 *             todo: action.todo,
 *           };
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
/**
 *
 * @whatItDoes Handles data fetching.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `fetch` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodos$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODOS'),
 *       fetch({
 *         // provides an action
 *         run: (a: GetTodos) => {
 *           return this.backend.getAll().pipe(
 *             map((response) => ({
 *               type: 'TODOS',
 *               todos: response.todos,
 *             }))
 *           );
 *         },
 *         onError: (action: GetTodos, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * This is correct, but because it set the concurrency to 1, it may not be performant.
 *
 * To fix that, you can provide the `id` function, like this:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODO'),
 *       fetch({
 *         id: (todo: GetTodo) => {
 *           return todo.id;
 *         },
 *         // provides an action
 *         run: (todo: GetTodo) => {
 *           return this.backend.getTodo(todo.id).map((response) => ({
 *             type: 'LOAD_TODO_SUCCESS',
 *             todo: response.todo,
 *           }));
 *         },
 *         onError: (action: GetTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
 *
 * In addition, if there are multiple requests for Todo 1 scheduled, it will only run the last one.
 *
 * @param opts
 */
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, ...store]) => {
                return opts.id(action, ...store);
            }));
            return groupedFetches.pipe(mergeMap((pairs) => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @whatItDoes Handles data fetching as part of router navigation.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `navigation` addresses these problems.
 *
 * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
 * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
 * the last request.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       // listens for the routerNavigation action from @ngrx/router-store
 *       navigation(TodoComponent, {
 *         run: (activatedRouteSnapshot: ActivatedRouteSnapshot) => {
 *           return this.backend
 *             .fetchTodo(activatedRouteSnapshot.params['id'])
 *             .pipe(
 *               map((todo) => ({
 *                 type: 'LOAD_TODO_SUCCESS',
 *                 todo: todo,
 *               }))
 *             );
 *         },
 *         onError: (
 *           activatedRouteSnapshot: ActivatedRouteSnapshot,
 *           error: any
 *         ) => {
 *           // we can log and error here and return null
 *           // we can also navigate back
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * @param component
 * @param opts
 */
export function navigation(component, opts) {
    return (source) => {
        const nav = source.pipe(mapActionAndState(), filter(([action]) => isStateSnapshot(action)), map(([action, ...slices]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                ...slices,
            ];
        }), filter(([snapshot]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return ([action, ...slices]) => {
        try {
            const r = wrapIntoObservable(run(action, ...slices));
            return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map((value) => normalizeActionAndState(value)));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and slices
 * into an array of action and slices (or undefined)
 */
function normalizeActionAndState(args) {
    let action, slices;
    if (args instanceof Array) {
        [action, ...slices] = args;
    }
    else {
        slices = [];
        action = args;
    }
    return [action, ...slices];
}
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (isObservable(obj)) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL3J1bnRpbWUvbngvZGF0YS1wZXJzaXN0ZW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUd2RCxPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLFNBQVMsRUFDVCxNQUFNLEVBQ04sT0FBTyxFQUNQLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxHQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFxQ3hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsSUFBaUM7SUFFakMsT0FBTyxDQUFDLE1BQWdDLEVBQXNCLEVBQUU7UUFDOUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FDeEQsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeURHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixJQUFnQztJQUVoQyxPQUFPLENBQUMsTUFBZ0MsRUFBc0IsRUFBRTtRQUM5RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLGlCQUFpQixFQUFFLEVBQ25CLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMs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QU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMzQixNQUFNLEVBQUUsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksRUFBRSxFQUFFLENBQUM7WUFDUCxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBSSxHQUE2QjtJQUMxRCxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3RCLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztTQUFNLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNoQixPQUFPLEVBQUUsRUFBRSxDQUFDO0lBQ2QsQ0FBQztTQUFNLENBQUM7UUFDTixPQUFPLEVBQUUsQ0FBQyxHQUFRLENBQUMsQ0FBQztJQUN0QixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUge1xuICBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICBSb3V0ZXJTdGF0ZVNuYXBzaG90LFxufSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHR5cGUgeyBSb3V0ZXJOYXZpZ2F0aW9uQWN0aW9uIH0gZnJvbSAnQG5ncngvcm91dGVyLXN0b3JlJztcbmltcG9ydCB7IFJPVVRFUl9OQVZJR0FUSU9OIH0gZnJvbSAnQG5ncngvcm91dGVyLXN0b3JlJztcbmltcG9ydCB0eXBlIHsgQWN0aW9uIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBpc09ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBjb25jYXRNYXAsXG4gIGZpbHRlcixcbiAgZ3JvdXBCeSxcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc3dpdGNoTWFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4ge1xuICBydW4oYTogQSwgLi4uc2xpY2VzOiBbLi4uVF0pOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpbWlzdGljVXBkYXRlT3B0czxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+IHtcbiAgcnVuKGE6IEEsIC4uLnNsaWNlczogWy4uLlRdKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgdW5kb0FjdGlvbihhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRzPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4ge1xuICBpZD8oYTogQSwgLi4uc2xpY2VzOiBbLi4uVF0pOiBhbnk7XG4gIHJ1bihhOiBBLCAuLi5zbGljZXM6IFsuLi5UXSk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4+IHtcbiAgcnVuKFxuICAgIGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsXG4gICAgLi4uc2xpY2VzOiBbLi4uVF1cbiAgKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPiA9XG4gIHwgQVxuICB8IFtBLCAuLi5UXTtcbmV4cG9ydCB0eXBlIEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+ID0gQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFtUXSwgQT47XG5leHBvcnQgdHlwZSBBY3Rpb25TdGF0ZXNTdHJlYW08VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPiA9IE9ic2VydmFibGU8XG4gIEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxULCBBPlxuPjtcbmV4cG9ydCB0eXBlIEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+ID0gT2JzZXJ2YWJsZTxcbiAgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFtUXSwgQT5cbj47XG5cbi8qKlxuICpcbiAqIEB3aGF0SXREb2VzIEhhbmRsZXMgcGVzc2ltaXN0aWMgdXBkYXRlcyAodXBkYXRpbmcgdGhlIHNlcnZlciBmaXJzdCkuXG4gKlxuICogVXBkYXRpbmcgdGhlIHNlcnZlciwgd2hlbiBpbXBsZW1lbnRlZCBuYWl2ZWx5LCBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIGBwZXNzaW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLiBJdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gKlxuICogIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIHVwZGF0ZVRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgb2ZUeXBlKCdVUERBVEVfVE9ETycpLFxuICogICAgICAgcGVzc2ltaXN0aWNVcGRhdGUoe1xuICogICAgICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb25cbiAqICAgICAgICAgcnVuOiAoYWN0aW9uOiBVcGRhdGVUb2RvKSA9PiB7XG4gKiAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBiYWNrZW5kIGZpcnN0LCBhbmQgdGhlbiBkaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCB3aWxsXG4gKiAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBjbGllbnQgc2lkZVxuICogICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQudXBkYXRlVG9kbyhhY3Rpb24udG9kby5pZCwgYWN0aW9uLnRvZG8pLnBpcGUoXG4gKiAgICAgICAgICAgICBtYXAoKHVwZGF0ZWQpID0+ICh7XG4gKiAgICAgICAgICAgICAgIHR5cGU6ICdVUERBVEVfVE9ET19TVUNDRVNTJyxcbiAqICAgICAgICAgICAgICAgdG9kbzogdXBkYXRlZCxcbiAqICAgICAgICAgICAgIH0pKVxuICogICAgICAgICAgICk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIG9uRXJyb3I6IChhY3Rpb246IFVwZGF0ZVRvZG8sIGVycm9yOiBhbnkpID0+IHtcbiAqICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVuZG8gdGhlIGNoYW5nZXMgb24gdGhlIGNsaWVudCBzaWRlLlxuICogICAgICAgICAgIC8vIHdlIGNhbiBkaXNwYXRjaCBhbiBlcnJvciwgb3Igc2ltcGx5IGxvZyB0aGUgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIGBudWxsYFxuICogICAgICAgICAgIHJldHVybiBudWxsO1xuICogICAgICAgICB9LFxuICogICAgICAgfSlcbiAqICAgICApXG4gKiAgICk7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGlvbnMkOiBBY3Rpb25zLCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICB1cGRhdGVUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIC8vLi4uXG4gKiAgICAgKSwgeyBkaXNwYXRjaDogZmFsc2UgfVxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlc3NpbWlzdGljVXBkYXRlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZXNTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKlxuICogQHdoYXRJdERvZXMgSGFuZGxlcyBvcHRpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBjbGllbnQgZmlyc3QpLlxuICpcbiAqIEl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICpcbiAqIFdoZW4gdXNpbmcgYG9wdGltaXN0aWNVcGRhdGVgLCBpbiBjYXNlIG9mIGEgZmFpbHVyZSwgdGhlIGRldmVsb3BlciBoYXMgYWxyZWFkeSB1cGRhdGVkIHRoZSBzdGF0ZSBsb2NhbGx5LFxuICogc28gdGhlIGRldmVsb3BlciBtdXN0IHByb3ZpZGUgYW4gdW5kbyBhY3Rpb24uXG4gKlxuICogVGhlIGVycm9yIGhhbmRsaW5nIG11c3QgYmUgZG9uZSBpbiB0aGUgY2FsbGJhY2ssIG9yIGJ5IG1lYW5zIG9mIHRoZSB1bmRvIGFjdGlvbi5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgdXBkYXRlVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICBvZlR5cGUoJ1VQREFURV9UT0RPJyksXG4gKiAgICAgICBvcHRpbWlzdGljVXBkYXRlKHtcbiAqICAgICAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uXG4gKiAgICAgICAgIHJ1bjogKGFjdGlvbjogVXBkYXRlVG9kbykgPT4ge1xuICogICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQudXBkYXRlVG9kbyhhY3Rpb24udG9kby5pZCwgYWN0aW9uLnRvZG8pLnBpcGUoXG4gKiAgICAgICAgICAgICBtYXBUbyh7XG4gKiAgICAgICAgICAgICAgIHR5cGU6ICdVUERBVEVfVE9ET19TVUNDRVNTJyxcbiAqICAgICAgICAgICAgIH0pXG4gKiAgICAgICAgICAgKTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgdW5kb0FjdGlvbjogKGFjdGlvbjogVXBkYXRlVG9kbywgZXJyb3I6IGFueSkgPT4ge1xuICogICAgICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICogICAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgICB0eXBlOiAnVU5ET19UT0RPX1VQREFURScsXG4gKiAgICAgICAgICAgICB0b2RvOiBhY3Rpb24udG9kbyxcbiAqICAgICAgICAgICB9O1xuICogICAgICAgICB9LFxuICogICAgICAgfSlcbiAqICAgICApXG4gKiAgICk7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGlvbnMkOiBBY3Rpb25zLCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICB1cGRhdGVUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIC8vLi4uXG4gKiAgICAgKSwgeyBkaXNwYXRjaDogZmFsc2UgfVxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXN0aWNVcGRhdGU8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVzU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLnVuZG9BY3Rpb24pKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICpcbiAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZy5cbiAqXG4gKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBgZmV0Y2hgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy4gSXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICBsb2FkVG9kb3MkID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgb2ZUeXBlKCdHRVRfVE9ET1MnKSxcbiAqICAgICAgIGZldGNoKHtcbiAqICAgICAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uXG4gKiAgICAgICAgIHJ1bjogKGE6IEdldFRvZG9zKSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRBbGwoKS5waXBlKFxuICogICAgICAgICAgICAgbWFwKChyZXNwb25zZSkgPT4gKHtcbiAqICAgICAgICAgICAgICAgdHlwZTogJ1RPRE9TJyxcbiAqICAgICAgICAgICAgICAgdG9kb3M6IHJlc3BvbnNlLnRvZG9zLFxuICogICAgICAgICAgICAgfSkpXG4gKiAgICAgICAgICAgKTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgb25FcnJvcjogKGFjdGlvbjogR2V0VG9kb3MsIGVycm9yOiBhbnkpID0+IHtcbiAqICAgICAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAqICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH0pXG4gKiAgICAgKVxuICogICApO1xuICpcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucywgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBpcyBjb3JyZWN0LCBidXQgYmVjYXVzZSBpdCBzZXQgdGhlIGNvbmN1cnJlbmN5IHRvIDEsIGl0IG1heSBub3QgYmUgcGVyZm9ybWFudC5cbiAqXG4gKiBUbyBmaXggdGhhdCwgeW91IGNhbiBwcm92aWRlIHRoZSBgaWRgIGZ1bmN0aW9uLCBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICBsb2FkVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICBvZlR5cGUoJ0dFVF9UT0RPJyksXG4gKiAgICAgICBmZXRjaCh7XG4gKiAgICAgICAgIGlkOiAodG9kbzogR2V0VG9kbykgPT4ge1xuICogICAgICAgICAgIHJldHVybiB0b2RvLmlkO1xuICogICAgICAgICB9LFxuICogICAgICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb25cbiAqICAgICAgICAgcnVuOiAodG9kbzogR2V0VG9kbykgPT4ge1xuICogICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0VG9kbyh0b2RvLmlkKS5tYXAoKHJlc3BvbnNlKSA9PiAoe1xuICogICAgICAgICAgICAgdHlwZTogJ0xPQURfVE9ET19TVUNDRVNTJyxcbiAqICAgICAgICAgICAgIHRvZG86IHJlc3BvbnNlLnRvZG8sXG4gKiAgICAgICAgICAgfSkpO1xuICogICAgICAgICB9LFxuICogICAgICAgICBvbkVycm9yOiAoYWN0aW9uOiBHZXRUb2RvLCBlcnJvcjogYW55KSA9PiB7XG4gKiAgICAgICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gKiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9KVxuICogICAgIClcbiAqICAgKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdpdGggdGhpcyBzZXR1cCwgdGhlIHJlcXVlc3RzIGZvciBUb2RvIDEgd2lsbCBydW4gY29uY3VycmVudGx5IHdpdGggdGhlIHJlcXVlc3RzIGZvciBUb2RvIDIuXG4gKlxuICogSW4gYWRkaXRpb24sIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHNjaGVkdWxlZCwgaXQgd2lsbCBvbmx5IHJ1biB0aGUgbGFzdCBvbmUuXG4gKlxuICogQHBhcmFtIG9wdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZldGNoPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IEZldGNoT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZXNTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIGlmIChvcHRzLmlkKSB7XG4gICAgICBjb25zdCBncm91cGVkRmV0Y2hlcyA9IHNvdXJjZS5waXBlKFxuICAgICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgICBncm91cEJ5KChbYWN0aW9uLCAuLi5zdG9yZV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0cy5pZChhY3Rpb24sIC4uLnN0b3JlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBncm91cGVkRmV0Y2hlcy5waXBlKFxuICAgICAgICBtZXJnZU1hcCgocGFpcnMpID0+XG4gICAgICAgICAgcGFpcnMucGlwZShzd2l0Y2hNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcgYXMgcGFydCBvZiByb3V0ZXIgbmF2aWdhdGlvbi5cbiAqXG4gKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBgbmF2aWdhdGlvbmAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLlxuICpcbiAqIEl0IGNoZWNrcyBpZiBhbiBhY3RpdmF0ZWQgcm91dGVyIHN0YXRlIGNvbnRhaW5zIHRoZSBwYXNzZWQgaW4gY29tcG9uZW50IHR5cGUsIGFuZCwgaWYgaXQgZG9lcywgcnVucyB0aGUgYHJ1bmBcbiAqIGNhbGxiYWNrLiBJdCBwcm92aWRlcyB0aGUgYWN0aXZhdGVkIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tcG9uZW50IGFuZCB0aGUgY3VycmVudCBzdGF0ZS4gQW5kIGl0IG9ubHkgcnVuc1xuICogdGhlIGxhc3QgcmVxdWVzdC5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgbG9hZFRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgLy8gbGlzdGVucyBmb3IgdGhlIHJvdXRlck5hdmlnYXRpb24gYWN0aW9uIGZyb20gQG5ncngvcm91dGVyLXN0b3JlXG4gKiAgICAgICBuYXZpZ2F0aW9uKFRvZG9Db21wb25lbnQsIHtcbiAqICAgICAgICAgcnVuOiAoYWN0aXZhdGVkUm91dGVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCkgPT4ge1xuICogICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmRcbiAqICAgICAgICAgICAgIC5mZXRjaFRvZG8oYWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wYXJhbXNbJ2lkJ10pXG4gKiAgICAgICAgICAgICAucGlwZShcbiAqICAgICAgICAgICAgICAgbWFwKCh0b2RvKSA9PiAoe1xuICogICAgICAgICAgICAgICAgIHR5cGU6ICdMT0FEX1RPRE9fU1VDQ0VTUycsXG4gKiAgICAgICAgICAgICAgICAgdG9kbzogdG9kbyxcbiAqICAgICAgICAgICAgICAgfSkpXG4gKiAgICAgICAgICAgICApO1xuICogICAgICAgICB9LFxuICogICAgICAgICBvbkVycm9yOiAoXG4gKiAgICAgICAgICAgYWN0aXZhdGVkUm91dGVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAqICAgICAgICAgICBlcnJvcjogYW55XG4gKiAgICAgICAgICkgPT4ge1xuICogICAgICAgICAgIC8vIHdlIGNhbiBsb2cgYW5kIGVycm9yIGhlcmUgYW5kIHJldHVybiBudWxsXG4gKiAgICAgICAgICAgLy8gd2UgY2FuIGFsc28gbmF2aWdhdGUgYmFja1xuICogICAgICAgICAgIHJldHVybiBudWxsO1xuICogICAgICAgICB9LFxuICogICAgICAgfSlcbiAqICAgICApXG4gKiAgICk7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGlvbnMkOiBBY3Rpb25zLCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gb3B0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbjxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVzU3RyZWFtPFQsIEE+KSA9PiB7XG4gICAgY29uc3QgbmF2ID0gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgZmlsdGVyKChbYWN0aW9uXSkgPT4gaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpLFxuICAgICAgbWFwKChbYWN0aW9uLCAuLi5zbGljZXNdKSA9PiB7XG4gICAgICAgIGlmICghaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBhYm92ZSBmaWx0ZXIgd2UnbGwgbmV2ZXIgZ2V0IGhlcmUsXG4gICAgICAgICAgLy8gYnV0IHRoaXMgcHJvcGVybHkgdHlwZSBuYXJyb3dzIGBhY3Rpb25gXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBmaW5kU25hcHNob3QoY29tcG9uZW50LCBhY3Rpb24ucGF5bG9hZC5yb3V0ZXJTdGF0ZS5yb290KSxcbiAgICAgICAgICAuLi5zbGljZXMsXG4gICAgICAgIF0gYXMgW0FjdGl2YXRlZFJvdXRlU25hcHNob3QsIC4uLlRdO1xuICAgICAgfSksXG4gICAgICBmaWx0ZXIoKFtzbmFwc2hvdF0pID0+ICEhc25hcHNob3QpXG4gICAgKTtcblxuICAgIHJldHVybiBuYXYucGlwZShzd2l0Y2hNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZVNuYXBzaG90KFxuICBhY3Rpb246IGFueVxuKTogYWN0aW9uIGlzIFJvdXRlck5hdmlnYXRpb25BY3Rpb248Um91dGVyU3RhdGVTbmFwc2hvdD4ge1xuICByZXR1cm4gYWN0aW9uLnR5cGUgPT09IFJPVVRFUl9OQVZJR0FUSU9OO1xufVxuXG5mdW5jdGlvbiBydW5XaXRoRXJyb3JIYW5kbGluZzxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEEsIFI+KFxuICBydW46IChhOiBBLCAuLi5zbGljZXM6IFsuLi5UXSkgPT4gT2JzZXJ2YWJsZTxSPiB8IFIgfCB2b2lkLFxuICBvbkVycm9yOiBhbnlcbikge1xuICByZXR1cm4gKFthY3Rpb24sIC4uLnNsaWNlc106IFtBLCAuLi5UXSk6IE9ic2VydmFibGU8Uj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gd3JhcEludG9PYnNlcnZhYmxlKHJ1bihhY3Rpb24sIC4uLnNsaWNlcykpO1xuICAgICAgcmV0dXJuIHIucGlwZShjYXRjaEVycm9yKChlKSA9PiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgbWFwcyBPYnNlcnZhYmxlPEFjdGlvbiB8IFtBY3Rpb24sIFN0YXRlXT4gdG9cbiAqIE9ic2VydmFibGU8W0FjdGlvbiwgU3RhdGVdPlxuICovXG5mdW5jdGlvbiBtYXBBY3Rpb25BbmRTdGF0ZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+KCkge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8VCwgQT4+KSA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGUodmFsdWUpIGFzIFtBLCAuLi5UXSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIE5vcm1hbGl6ZXMgZWl0aGVyIGEgYmFyZSBhY3Rpb24gb3IgYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzbGljZXNcbiAqIGludG8gYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzbGljZXMgKG9yIHVuZGVmaW5lZClcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGU8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPihcbiAgYXJnczogQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFQsIEE+XG4pOiBbQSwgLi4uVF0ge1xuICBsZXQgYWN0aW9uOiBBLCBzbGljZXM6IFQ7XG5cbiAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIFthY3Rpb24sIC4uLnNsaWNlc10gPSBhcmdzO1xuICB9IGVsc2Uge1xuICAgIHNsaWNlcyA9IFtdIGFzIFQ7XG4gICAgYWN0aW9uID0gYXJncztcbiAgfVxuXG4gIHJldHVybiBbYWN0aW9uLCAuLi5zbGljZXNdO1xufVxuXG5mdW5jdGlvbiBmaW5kU25hcHNob3QoXG4gIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICBzOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90XG4pOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHtcbiAgaWYgKHMucm91dGVDb25maWcgJiYgcy5yb3V0ZUNvbmZpZy5jb21wb25lbnQgPT09IGNvbXBvbmVudCkge1xuICAgIHJldHVybiBzO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBzLmNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc3MgPSBmaW5kU25hcHNob3QoY29tcG9uZW50LCBjKTtcbiAgICBpZiAoc3MpIHtcbiAgICAgIHJldHVybiBzcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbnRvT2JzZXJ2YWJsZTxPPihvYmo6IE9ic2VydmFibGU8Tz4gfCBPIHwgdm9pZCk6IE9ic2VydmFibGU8Tz4ge1xuICBpZiAoaXNPYnNlcnZhYmxlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2UgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gb2YoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2Yob2JqIGFzIE8pO1xuICB9XG59XG4iXX0=