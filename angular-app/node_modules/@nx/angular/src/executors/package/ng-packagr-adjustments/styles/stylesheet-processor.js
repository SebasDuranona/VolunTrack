"use strict";
/**
 * Adapted from the original ng-packagr source.
 *
 * Changes made:
 * - Refactored caching to take into account TailwindCSS processing.
 * - Added PostCSS plugin needed to support TailwindCSS.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StylesheetProcessor = exports.CssUrl = void 0;
const browserslist = require("browserslist");
const fs_1 = require("fs");
const esbuild_executor_1 = require("ng-packagr/lib/esbuild/esbuild-executor");
const cache_1 = require("ng-packagr/lib/utils/cache");
const log = require("ng-packagr/lib/utils/log");
const path_1 = require("path");
const autoprefixer = require("autoprefixer");
const postcssUrl = require("postcss-url");
const node_url_1 = require("node:url");
const tailwindcss_1 = require("../../../utilities/ng-packagr/tailwindcss");
const postcss = require('postcss');
var CssUrl;
(function (CssUrl) {
    CssUrl["inline"] = "inline";
    CssUrl["none"] = "none";
})(CssUrl || (exports.CssUrl = CssUrl = {}));
class StylesheetProcessor {
    constructor(projectBasePath, basePath, cssUrl, includePaths, cacheDirectory, tailwindConfig) {
        this.projectBasePath = projectBasePath;
        this.basePath = basePath;
        this.cssUrl = cssUrl;
        this.includePaths = includePaths;
        this.cacheDirectory = cacheDirectory;
        this.tailwindConfig = tailwindConfig;
        this.esbuild = new esbuild_executor_1.EsbuildExecutor();
        // By default, browserslist defaults are too inclusive
        // https://github.com/browserslist/browserslist/blob/83764ea81ffaa39111c204b02c371afa44a4ff07/index.js#L516-L522
        // We change the default query to browsers that Angular support.
        // https://angular.io/guide/browser-support
        browserslist.defaults = [
            'last 2 Chrome versions',
            'last 1 Firefox version',
            'last 2 Edge major versions',
            'last 2 Safari major versions',
            'last 2 iOS major versions',
            'Firefox ESR',
        ];
        this.styleIncludePaths = [...this.includePaths];
        let prevDir = null;
        let currentDir = this.basePath;
        while (currentDir !== prevDir) {
            const p = (0, path_1.join)(currentDir, 'node_modules');
            if ((0, fs_1.existsSync)(p)) {
                this.styleIncludePaths.push(p);
            }
            prevDir = currentDir;
            currentDir = (0, path_1.dirname)(prevDir);
        }
        this.browserslistData = browserslist(undefined, { path: this.basePath });
        this.targets = transformSupportedBrowsersToTargets(this.browserslistData);
        const tailwindSetup = (0, tailwindcss_1.getTailwindSetup)(this.projectBasePath, this.tailwindConfig);
        if (tailwindSetup) {
            this.cacheDirectory = undefined;
        }
        this.postCssProcessor = this.createPostCssProcessor(tailwindSetup);
    }
    async process({ filePath, content, }) {
        const CACHE_KEY_VALUES = [
            ...this.browserslistData,
            ...this.styleIncludePaths,
            this.cssUrl,
        ].join(':');
        let key;
        if (this.cacheDirectory &&
            !content.includes('@import') &&
            !content.includes('@use')) {
            // No transitive deps and no Tailwind directives, we can cache more aggressively.
            key = await (0, cache_1.generateKey)(content, CACHE_KEY_VALUES);
            const result = await (0, cache_1.readCacheEntry)(this.cacheDirectory, key);
            if (result) {
                result.warnings.forEach((msg) => log.warn(msg));
                return result.css;
            }
        }
        // Render pre-processor language (sass, styl, less)
        const renderedCss = await this.renderCss(filePath, content);
        // We cannot cache CSS re-rendering phase, because a transitive dependency via (@import) can case different CSS output.
        // Example a change in a mixin or SCSS variable.
        if (!key) {
            key = await (0, cache_1.generateKey)(renderedCss, CACHE_KEY_VALUES);
        }
        if (this.cacheDirectory) {
            const cachedResult = await (0, cache_1.readCacheEntry)(this.cacheDirectory, key);
            if (cachedResult) {
                cachedResult.warnings.forEach((msg) => log.warn(msg));
                return cachedResult.css;
            }
        }
        // Render postcss (autoprefixing and friends)
        const result = await this.postCssProcessor.process(renderedCss, {
            from: filePath,
            to: filePath.replace((0, path_1.extname)(filePath), '.css'),
        });
        const warnings = result.warnings().map((w) => w.toString());
        const { code, warnings: esBuildWarnings } = await this.esbuild.transform(result.css, {
            loader: 'css',
            minify: true,
            target: this.targets,
            sourcefile: filePath,
        });
        if (esBuildWarnings.length > 0) {
            warnings.push(...(await this.esbuild.formatMessages(esBuildWarnings, {
                kind: 'warning',
            })));
        }
        if (this.cacheDirectory) {
            await (0, cache_1.saveCacheEntry)(this.cacheDirectory, key, JSON.stringify({
                css: code,
                warnings,
            }));
        }
        warnings.forEach((msg) => log.warn(msg));
        return code;
    }
    createPostCssProcessor(tailwindSetup) {
        const postCssPlugins = [];
        if (tailwindSetup) {
            postCssPlugins.push((0, tailwindcss_1.getTailwindPostCssPlugin)(tailwindSetup));
        }
        if (this.cssUrl !== CssUrl.none) {
            postCssPlugins.push(postcssUrl({ url: this.cssUrl }));
        }
        postCssPlugins.push(autoprefixer({
            ignoreUnknownVersions: true,
            overrideBrowserslist: this.browserslistData,
        }));
        return postcss(postCssPlugins);
    }
    async renderCss(filePath, css) {
        const ext = (0, path_1.extname)(filePath);
        switch (ext) {
            case '.sass':
            case '.scss': {
                return (await Promise.resolve().then(() => require('sass'))).compileString(css, {
                    url: (0, node_url_1.pathToFileURL)(filePath),
                    syntax: '.sass' === ext ? 'indented' : 'scss',
                    loadPaths: this.styleIncludePaths,
                }).css;
            }
            case '.less': {
                const { css: content } = await (await Promise.resolve().then(() => require('less'))).render(css, {
                    filename: filePath,
                    javascriptEnabled: true,
                    paths: this.styleIncludePaths,
                });
                return content;
            }
            case '.css':
            default:
                return css;
        }
    }
}
exports.StylesheetProcessor = StylesheetProcessor;
function transformSupportedBrowsersToTargets(supportedBrowsers) {
    const transformed = [];
    // https://esbuild.github.io/api/#target
    const esBuildSupportedBrowsers = new Set([
        'safari',
        'firefox',
        'edge',
        'chrome',
        'ios',
    ]);
    for (const browser of supportedBrowsers) {
        let [browserName, version] = browser.split(' ');
        // browserslist uses the name `ios_saf` for iOS Safari whereas esbuild uses `ios`
        if (browserName === 'ios_saf') {
            browserName = 'ios';
        }
        // browserslist uses ranges `15.2-15.3` versions but only the lowest is required
        // to perform minimum supported feature checks. esbuild also expects a single version.
        [version] = version.split('-');
        if (esBuildSupportedBrowsers.has(browserName)) {
            if (browserName === 'safari' && version === 'tp') {
                // esbuild only supports numeric versions so `TP` is converted to a high number (999) since
                // a Technology Preview (TP) of Safari is assumed to support all currently known features.
                version = '999';
            }
            transformed.push(browserName + version);
        }
    }
    return transformed.length ? transformed : undefined;
}
