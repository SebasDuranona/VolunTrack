"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateWebpackConfig = void 0;
const devkit_1 = require("@nx/devkit");
function generateWebpackConfig(tree, options, appRoot, remotesWithPorts) {
    if (tree.exists(`${appRoot}/module-federation.config.js`) ||
        tree.exists(`${appRoot}/webpack.config.js`) ||
        tree.exists(`${appRoot}/webpack.prod.config.js`) ||
        tree.exists(`${appRoot}/module-federation.config.ts`) ||
        tree.exists(`${appRoot}/webpack.config.ts`) ||
        tree.exists(`${appRoot}/webpack.prod.config.ts`)) {
        devkit_1.logger.warn(`NOTE: We encountered an existing webpack config for the app ${options.appName}. We have overwritten this file with the Module Federation Config.\n
      If this was not the outcome you expected, you can discard the changes we have made, create a backup of your current webpack config, and run the command again.`);
    }
    const pathToWebpackTemplateFiles = options.typescriptConfiguration
        ? 'ts-webpack'
        : 'webpack';
    (0, devkit_1.generateFiles)(tree, (0, devkit_1.joinPathFragments)(__dirname, `../files/${pathToWebpackTemplateFiles}`), appRoot, {
        tmpl: '',
        type: options.mfType,
        name: options.appName,
        remotes: remotesWithPorts ?? [],
        projectRoot: appRoot,
        standalone: options.standalone,
    });
    if (!options.setParserOptionsProject) {
        tree.delete((0, devkit_1.joinPathFragments)(appRoot, 'tsconfig.lint.json'));
    }
}
exports.generateWebpackConfig = generateWebpackConfig;
