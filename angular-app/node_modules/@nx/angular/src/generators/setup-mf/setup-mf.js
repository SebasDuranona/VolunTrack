"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMf = void 0;
const devkit_1 = require("@nx/devkit");
const lib_1 = require("./lib");
const versions_1 = require("../../utils/versions");
async function setupMf(tree, rawOptions) {
    const options = (0, lib_1.normalizeOptions)(tree, rawOptions);
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.appName);
    let installTask = () => { };
    if (options.mfType === 'remote') {
        (0, lib_1.addRemoteToHost)(tree, options);
        (0, lib_1.addRemoteEntry)(tree, options, projectConfig.root);
        (0, lib_1.removeDeadCodeFromRemote)(tree, options);
        (0, lib_1.setupTspathForRemote)(tree, options);
        installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { '@nx/web': versions_1.nxVersion, '@nx/webpack': versions_1.nxVersion });
    }
    const remotesWithPorts = (0, lib_1.getRemotesWithPorts)(tree, options);
    (0, lib_1.generateWebpackConfig)(tree, options, projectConfig.root, remotesWithPorts);
    (0, lib_1.changeBuildTarget)(tree, options);
    (0, lib_1.updateTsConfig)(tree, options);
    (0, lib_1.setupServeTarget)(tree, options);
    (0, lib_1.fixBootstrap)(tree, projectConfig.root, options);
    if (options.mfType === 'host') {
        (0, lib_1.setupHostIfDynamic)(tree, options);
        (0, lib_1.updateHostAppRoutes)(tree, options);
        installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { '@nx/webpack': versions_1.nxVersion });
    }
    if (!options.skipE2E) {
        (0, lib_1.addCypressOnErrorWorkaround)(tree, options);
    }
    // format files
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return installTask;
}
exports.setupMf = setupMf;
exports.default = setupMf;
