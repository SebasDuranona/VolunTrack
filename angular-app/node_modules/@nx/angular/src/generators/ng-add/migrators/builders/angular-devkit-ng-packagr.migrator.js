"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularDevkitNgPackagrMigrator = void 0;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const path_1 = require("path");
const dependencies_1 = require("../../../utils/dependencies");
const builder_migrator_1 = require("./builder.migrator");
class AngularDevkitNgPackagrMigrator extends builder_migrator_1.BuilderMigrator {
    constructor(tree, project, projectConfig, logger) {
        super(tree, '@angular-devkit/build-angular:ng-packagr', undefined, project, projectConfig, logger);
    }
    migrate() {
        if (this.skipMigration) {
            return;
        }
        if (!this.targets.size) {
            this.logger.warn(`There is no target in the project configuration using the ${this.builderName} builder. This might not be an issue. ` +
                `Skipping updating the build configuration.`);
            return;
        }
        for (const [name, target] of this.targets) {
            this.updateTargetConfiguration(name, target);
            this.updateNgPackageJson(name, target);
            this.updateTsConfigs(name, target);
            this.updateCacheableOperations([name]);
            (0, dependencies_1.addBuildableLibrariesPostCssDependencies)(this.tree);
        }
    }
    updateTargetConfiguration(targetName, target) {
        target.executor = '@nx/angular:package';
        if (!target.options &&
            (!target.configurations || !Object.keys(target.configurations).length)) {
            this.logger.warn(`The target "${targetName}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        ['project', 'tsConfig'].forEach((option) => {
            if (target.options?.[option]) {
                target.options[option] = (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(target.options[option]));
            }
            for (const configuration of Object.values(target.configurations ?? {})) {
                configuration[option] =
                    configuration[option] &&
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(configuration[option]));
            }
        });
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, {
            ...this.projectConfig,
        });
    }
    updateNgPackageJson(targetName, target) {
        if (!target.options?.project) {
            this.logger.warn(`The "${targetName}" target does not have the "project" option configured. Skipping updating the ng-packagr project file ("ng-package.json").`);
            return;
        }
        else if (!this.tree.exists(target.options.project)) {
            this.logger.warn(`The ng-packagr project file "${this.originalProjectConfig.targets[targetName].options.project}" specified in the "${targetName}" ` +
                `target could not be found. Skipping updating the ng-packagr project file.`);
            return;
        }
        (0, devkit_1.updateJson)(this.tree, target.options.project, (ngPackageJson) => {
            const offset = (0, devkit_1.offsetFromRoot)(this.project.newRoot);
            ngPackageJson.$schema =
                ngPackageJson.$schema &&
                    `${offset}node_modules/ng-packagr/ng-package.schema.json`;
            ngPackageJson.dest = `${offset}dist/${this.project.name}`;
            return ngPackageJson;
        });
    }
    updateTsConfigs(targetName, target) {
        const tsConfigPath = target.options?.tsConfig ?? target.configurations?.development?.tsConfig;
        if (!tsConfigPath) {
            this.logger.warn(`The "${targetName}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
            return;
        }
        else if (!this.tree.exists(tsConfigPath)) {
            const originalTsConfigPath = target.options?.tsConfig
                ? this.originalProjectConfig.targets[targetName].options.tsConfig
                : this.originalProjectConfig.targets[targetName].configurations
                    ?.development?.tsConfig;
            this.logger.warn(`The tsConfig file "${originalTsConfigPath}" specified in the "${targetName}" target could not be found. Skipping updating the tsConfig file.`);
            return;
        }
        const rootTsConfigFile = (0, js_1.getRootTsConfigPathInTree)(this.tree);
        const projectOffsetFromRoot = (0, devkit_1.offsetFromRoot)(this.projectConfig.root);
        this.updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot);
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            if (!json.include?.length && !json.files?.length) {
                json.include = ['**/*.ts'];
            }
            return json;
        });
    }
}
exports.AngularDevkitNgPackagrMigrator = AngularDevkitNgPackagrMigrator;
