"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addTailwindConfigPathToProject = void 0;
const devkit_1 = require("@nx/devkit");
function addTailwindConfigPathToProject(tree, options, project) {
    const buildTarget = project.targets?.[options.buildTarget];
    if (!buildTarget) {
        throw new Error((0, devkit_1.stripIndents) `The target "${options.buildTarget}" was not found for project "${options.project}".
      If you are using a different build target, please provide it using the "--buildTarget" option.
      If the project is not a buildable or publishable library, you don't need to setup TailwindCSS for it.`);
    }
    const supportedLibraryExecutors = [
        '@nx/angular:ng-packagr-lite',
        '@nx/angular:package',
        '@nrwl/angular:ng-packagr-lite',
        '@nrwl/angular:package',
    ];
    if (!supportedLibraryExecutors.includes(buildTarget.executor)) {
        throw new Error((0, devkit_1.stripIndents) `The build target for project "${options.project}" is using an unsupported executor "${buildTarget.executor}".
      Supported executors are ${supportedLibraryExecutors
            .map((e) => `"${e}"`)
            .join(', ')}.`);
    }
    if (buildTarget.options?.tailwindConfig &&
        tree.exists(buildTarget.options.tailwindConfig)) {
        throw new Error((0, devkit_1.stripIndents) `The "${buildTarget.options.tailwindConfig}" file is already configured for the project "${options.project}". Are you sure this is the right project to set up Tailwind?
      If you are sure, you can remove the configuration and re-run the generator.`);
    }
    buildTarget.options = {
        ...buildTarget.options,
        tailwindConfig: (0, devkit_1.joinPathFragments)(project.root, 'tailwind.config.js'),
    };
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, project);
}
exports.addTailwindConfigPathToProject = addTailwindConfigPathToProject;
