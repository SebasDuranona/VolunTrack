"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cypressComponentConfigurationInternal = exports.cypressComponentConfiguration = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const versions_1 = require("../../utils/versions");
const component_test_1 = require("../component-test/component-test");
const component_info_1 = require("../utils/storybook-ast/component-info");
const entry_point_1 = require("../utils/storybook-ast/entry-point");
const module_info_1 = require("../utils/storybook-ast/module-info");
const update_app_editor_tsconfig_excluded_files_1 = require("../utils/update-app-editor-tsconfig-excluded-files");
function cypressComponentConfiguration(tree, options) {
    return cypressComponentConfigurationInternal(tree, {
        ...options,
    });
}
exports.cypressComponentConfiguration = cypressComponentConfiguration;
/**
 * This is for cypress built in component testing, if you want to test with
 * storybook + cypress then use the componentCypressGenerator instead.
 */
async function cypressComponentConfigurationInternal(tree, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const { componentConfigurationGenerator: baseCyCTConfig } = (0, devkit_1.ensurePackage)('@nx/cypress', versions_1.nxVersion);
    const installTask = await baseCyCTConfig(tree, {
        project: options.project,
        skipFormat: true,
        addPlugin: false,
        addExplicitTargets: true,
    });
    await configureCypressCT(tree, options);
    await addFiles(tree, projectConfig, options);
    if (projectConfig.projectType === 'application') {
        (0, update_app_editor_tsconfig_excluded_files_1.updateAppEditorTsConfigExcludedFiles)(tree, projectConfig);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return installTask;
}
exports.cypressComponentConfigurationInternal = cypressComponentConfigurationInternal;
async function addFiles(tree, projectConfig, options) {
    const componentFile = (0, devkit_1.joinPathFragments)(projectConfig.root, 'cypress', 'support', 'component.ts');
    const { addMountDefinition } = await Promise.resolve().then(() => require('@nx/cypress/src/utils/config'));
    const updatedCmpContents = await addMountDefinition(tree.read(componentFile, 'utf-8'));
    tree.write(componentFile, `import { mount } from 'cypress/angular';\n${updatedCmpContents}`);
    if (options.generateTests) {
        const entryPoints = (0, entry_point_1.getProjectEntryPoints)(tree, options.project);
        const componentInfo = [];
        for (const entryPoint of entryPoints) {
            const moduleFilePaths = (0, module_info_1.getModuleFilePaths)(tree, entryPoint);
            componentInfo.push(...(0, component_info_1.getComponentsInfo)(tree, entryPoint, moduleFilePaths, options.project), ...(0, component_info_1.getStandaloneComponentsInfo)(tree, entryPoint));
        }
        for (const info of componentInfo) {
            if (info === undefined) {
                continue;
            }
            const componentDirFromProjectRoot = (0, path_1.relative)(projectConfig.root, (0, devkit_1.joinPathFragments)(info.moduleFolderPath, info.path));
            await (0, component_test_1.componentTestGenerator)(tree, {
                project: options.project,
                componentName: info.name,
                componentDir: componentDirFromProjectRoot,
                componentFileName: info.componentFileName,
                skipFormat: true,
            });
        }
    }
}
async function configureCypressCT(tree, options) {
    let found = { target: options.buildTarget, config: undefined };
    if (!options.buildTarget) {
        const { findBuildConfig } = await Promise.resolve().then(() => require('@nx/cypress/src/utils/find-target-options'));
        found = await findBuildConfig(tree, {
            project: options.project,
            buildTarget: options.buildTarget,
            validExecutorNames: new Set([
                '@nx/angular:webpack-browser',
                '@nrwl/angular:webpack-browser',
                '@angular-devkit/build-angular:browser',
            ]),
        });
        assertValidConfig(found?.config);
    }
    const ctConfigOptions = {};
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    if (projectConfig.targets?.['component-test']?.executor ===
        '@nx/cypress:cypress') {
        projectConfig.targets['component-test'].options = {
            ...projectConfig.targets['component-test'].options,
            skipServe: true,
            devServerTarget: found.target,
        };
        (0, devkit_1.updateProjectConfiguration)(tree, options.project, projectConfig);
    }
    else {
        ctConfigOptions.buildTarget = found.target;
    }
    const { addDefaultCTConfig, getProjectCypressConfigPath } = await Promise.resolve().then(() => require('@nx/cypress/src/utils/config'));
    const cypressConfigPath = getProjectCypressConfigPath(tree, projectConfig.root);
    const updatedCyConfig = await addDefaultCTConfig(tree.read(cypressConfigPath, 'utf-8'), ctConfigOptions);
    tree.write(cypressConfigPath, `import { nxComponentTestingPreset } from '@nx/angular/plugins/component-testing';\n${updatedCyConfig}`);
}
function assertValidConfig(config) {
    if (!config) {
        throw new Error('Unable to find a valid build configuration. Try passing in a target for an Angular app. --build-target=<project>:<target>[:<configuration>]');
    }
}
exports.default = cypressComponentConfiguration;
