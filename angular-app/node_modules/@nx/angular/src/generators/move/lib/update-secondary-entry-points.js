"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateSecondaryEntryPoints = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const libraryExecutors = [
    '@angular-devkit/build-angular:ng-packagr',
    '@nx/angular:ng-packagr-lite',
    '@nx/angular:package',
    // TODO(v17): remove when @nrwl/* scope is removed
    '@nrwl/angular:ng-packagr-lite',
    '@nrwl/angular:package',
];
function updateSecondaryEntryPoints(tree, schema) {
    if (schema.oldProjectName === schema.newProjectName) {
        return;
    }
    const project = (0, devkit_1.readProjectConfiguration)(tree, schema.newProjectName);
    if (project.projectType !== 'library') {
        return;
    }
    if (!Object.values(project.targets ?? {}).some((target) => libraryExecutors.includes(target.executor))) {
        return;
    }
    (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (filePath) => {
        if ((0, path_1.basename)(filePath) !== 'ng-package.json' ||
            (0, devkit_1.normalizePath)(filePath) ===
                (0, devkit_1.joinPathFragments)(project.root, 'ng-package.json')) {
            return;
        }
        updateReadme(tree, (0, path_1.dirname)(filePath), schema.oldProjectName, schema.newProjectName);
    });
}
exports.updateSecondaryEntryPoints = updateSecondaryEntryPoints;
function updateReadme(tree, dir, oldProjectName, newProjectName) {
    const readmePath = (0, devkit_1.joinPathFragments)(dir, 'README.md');
    if (!tree.exists(readmePath)) {
        return;
    }
    const findName = new RegExp(`${oldProjectName}`, 'g');
    const oldContent = tree.read(readmePath, 'utf-8');
    const newContent = oldContent.replace(findName, newProjectName);
    tree.write(readmePath, newContent);
}
