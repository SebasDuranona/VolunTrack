"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeModuleFederationDevSSRBuilder = void 0;
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const ngcli_adapter_1 = require("nx/src/adapter/ngcli-adapter");
const executor_utils_1 = require("nx/src/command-line/run/executor-utils");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const angular_version_utils_1 = require("../../executors/utilities/angular-version-utils");
const module_federation_1 = require("../utilities/module-federation");
function executeModuleFederationDevSSRBuilder(schema, context) {
    const { ...options } = schema;
    const projectGraph = (0, devkit_1.readCachedProjectGraph)();
    const { projects: workspaceProjects } = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph);
    const project = workspaceProjects[context.target.project];
    let pathToManifestFile = (0, path_1.join)(context.workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json');
    if (options.pathToManifestFile) {
        const userPathToManifestFile = (0, path_1.join)(context.workspaceRoot, options.pathToManifestFile);
        if (!(0, fs_1.existsSync)(userPathToManifestFile)) {
            throw new Error(`The provided Module Federation manifest file path does not exist. Please check the file exists at "${userPathToManifestFile}".`);
        }
        else if ((0, path_1.extname)(options.pathToManifestFile) !== '.json') {
            throw new Error(`The Module Federation manifest file must be a JSON. Please ensure the file at ${userPathToManifestFile} is a JSON.`);
        }
        pathToManifestFile = userPathToManifestFile;
    }
    (0, module_federation_1.validateDevRemotes)(options, workspaceProjects);
    const remotesToSkip = new Set(options.skipRemotes ?? []);
    const staticRemotes = (0, module_federation_1.getStaticRemotes)(project, context, workspaceProjects, remotesToSkip);
    const dynamicRemotes = (0, module_federation_1.getDynamicRemotes)(project, context, workspaceProjects, remotesToSkip, pathToManifestFile);
    const remotes = [...staticRemotes, ...dynamicRemotes];
    const devServeRemotes = !options.devRemotes
        ? []
        : Array.isArray(options.devRemotes)
            ? options.devRemotes
            : [options.devRemotes];
    const remoteProcessPromises = [];
    for (const remote of remotes) {
        const isDev = devServeRemotes.includes(remote);
        const target = isDev ? 'serve-ssr' : 'static-server';
        if (!workspaceProjects[remote].targets?.[target]) {
            throw new Error(`Could not find "${target}" target in "${remote}" project.`);
        }
        else if (!workspaceProjects[remote].targets?.[target].executor) {
            throw new Error(`Could not find executor for "${target}" target in "${remote}" project.`);
        }
        const runOptions = {};
        if (options.verbose) {
            const [collection, executor] = workspaceProjects[remote].targets[target].executor.split(':');
            const { schema } = (0, executor_utils_1.getExecutorInformation)(collection, executor, devkit_1.workspaceRoot, workspaceProjects);
            if (schema.additionalProperties || 'verbose' in schema.properties) {
                runOptions.verbose = options.verbose;
            }
        }
        const remotePromise = new Promise((res, rej) => {
            if (target === 'static-server') {
                const remoteProject = workspaceProjects[remote];
                const remoteServerOutput = (0, path_1.join)(devkit_1.workspaceRoot, remoteProject.targets.server.options.outputPath, 'main.js');
                const pm = (0, devkit_1.getPackageManagerCommand)();
                (0, child_process_1.execSync)(`${pm.exec} nx run ${remote}:server${context.target.configuration
                    ? `:${context.target.configuration}`
                    : ''}`, { stdio: 'inherit' });
                const child = (0, child_process_1.fork)(remoteServerOutput, {
                    env: { PORT: remoteProject.targets['serve-ssr'].options.port },
                });
                child.on('message', (msg) => {
                    if (msg === 'nx.server.ready') {
                        res();
                    }
                });
            }
            if (target === 'serve-ssr') {
                (0, ngcli_adapter_1.scheduleTarget)(context.workspaceRoot, {
                    project: remote,
                    target,
                    configuration: context.target.configuration,
                    runOptions,
                    projects: workspaceProjects,
                }, options.verbose).then((obs) => obs
                    .pipe((0, operators_1.tap)((result) => {
                    result.success && res();
                }))
                    .toPromise());
            }
        });
        remoteProcessPromises.push(remotePromise);
    }
    const { major: angularMajorVersion } = (0, angular_version_utils_1.getInstalledAngularVersionInfo)();
    const { executeSSRDevServerBuilder } = angularMajorVersion >= 17
        ? require('@angular-devkit/build-angular')
        : require('@nguniversal/builders');
    return (0, rxjs_1.from)(Promise.all(remoteProcessPromises)).pipe((0, operators_1.switchMap)(() => executeSSRDevServerBuilder(options, context)));
}
exports.executeModuleFederationDevSSRBuilder = executeModuleFederationDevSSRBuilder;
exports.default = require('@angular-devkit/architect').createBuilder(executeModuleFederationDevSSRBuilder);
