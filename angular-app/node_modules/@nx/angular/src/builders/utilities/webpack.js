"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveIndexHtmlTransformer = exports.resolveCustomWebpackConfig = exports.mergeCustomWebpackConfig = void 0;
const webpack_merge_1 = require("webpack-merge");
const internal_1 = require("@nx/js/src/internal");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
async function mergeCustomWebpackConfig(baseWebpackConfig, pathToWebpackConfig, options, target) {
    const customWebpackConfiguration = resolveCustomWebpackConfig(pathToWebpackConfig, options.tsConfig.startsWith(devkit_1.workspaceRoot)
        ? options.tsConfig
        : (0, path_1.join)(devkit_1.workspaceRoot, options.tsConfig));
    // The extra Webpack configuration file can also export a Promise, for instance:
    // `module.exports = new Promise(...)`. If it exports a single object, but not a Promise,
    // then await will just resolve that object.
    const config = await customWebpackConfiguration;
    // The extra Webpack configuration file can export a synchronous or asynchronous function,
    // for instance: `module.exports = async config => { ... }`.
    if (typeof config === 'function') {
        return config(baseWebpackConfig, options, target);
    }
    else {
        return (0, webpack_merge_1.merge)(baseWebpackConfig, config);
    }
}
exports.mergeCustomWebpackConfig = mergeCustomWebpackConfig;
function resolveCustomWebpackConfig(path, tsConfig) {
    const cleanupTranspiler = (0, internal_1.registerTsProject)(tsConfig);
    const customWebpackConfig = require(path);
    cleanupTranspiler();
    // If the user provides a configuration in TS file
    // then there are 2 cases for exporting an object. The first one is:
    // `module.exports = { ... }`. And the second one is:
    // `export default { ... }`. The ESM format is compiled into:
    // `{ default: { ... } }`
    return customWebpackConfig.default ?? customWebpackConfig;
}
exports.resolveCustomWebpackConfig = resolveCustomWebpackConfig;
function resolveIndexHtmlTransformer(path, tsConfig, target) {
    const cleanupTranspiler = (0, internal_1.registerTsProject)(tsConfig);
    const indexTransformer = require(path);
    cleanupTranspiler();
    const transform = indexTransformer.default ?? indexTransformer;
    return (indexHtml) => transform(target, indexHtml);
}
exports.resolveIndexHtmlTransformer = resolveIndexHtmlTransformer;
