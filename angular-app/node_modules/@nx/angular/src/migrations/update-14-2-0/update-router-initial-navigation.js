"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const devkit_1 = require("@nx/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const typescript_1 = require("typescript");
async function default_1(tree) {
    const printer = (0, typescript_1.createPrinter)();
    const projects = await getProjectsWithAngularRouter(tree);
    for (const project of projects) {
        (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (filePath) => {
            // we are only interested in .ts files
            if (!filePath.endsWith('.ts')) {
                return;
            }
            const content = tree.read(filePath, 'utf-8');
            const ast = tsquery_1.tsquery.ast(content);
            const routerModuleForRootCall = getRouterModuleForRootCall(ast);
            if (!routerModuleForRootCall) {
                return;
            }
            const initialNavigationAssignment = getInitialNavigationAssignment(routerModuleForRootCall.arguments[1]);
            if (!initialNavigationAssignment) {
                return;
            }
            const updatedInitialNavigationAssignment = printer.printNode(typescript_1.EmitHint.Unspecified, typescript_1.factory.updatePropertyAssignment(initialNavigationAssignment, initialNavigationAssignment.name, typescript_1.factory.createIdentifier(`'enabledBlocking'`)), initialNavigationAssignment.getSourceFile());
            const updatedContent = `${content.slice(0, initialNavigationAssignment.getStart())}${updatedInitialNavigationAssignment}${content.slice(initialNavigationAssignment.getEnd())}`;
            tree.write(filePath, updatedContent);
        });
    }
    await (0, devkit_1.formatFiles)(tree);
}
exports.default = default_1;
function getInitialNavigationAssignment(extraOptionsLiteral) {
    for (const prop of extraOptionsLiteral.properties) {
        if ((0, typescript_1.isPropertyAssignment)(prop) &&
            ((0, typescript_1.isIdentifier)(prop.name) || (0, typescript_1.isStringLiteralLike)(prop.name)) &&
            prop.name.text === 'initialNavigation' &&
            needsMigration(prop)) {
            return prop;
        }
    }
    return null;
}
async function getProjectsWithAngularRouter(tree) {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    return Object.entries(projectGraph.dependencies)
        .filter(([node, dep]) => dep.some(({ target }) => target === 'npm:@angular/router' &&
        !projectGraph.externalNodes?.[node]))
        .map(([projectName]) => (0, devkit_1.readProjectConfiguration)(tree, projectName));
}
function getRouterModuleForRootCall(sourceFile) {
    // narrow down call expressions
    const routerModuleForRootCalls = (0, tsquery_1.tsquery)(sourceFile, 'CallExpression:has(PropertyAccessExpression:has(Identifier[name=RouterModule]):has(Identifier[name=forRoot]))', { visitAllChildren: true });
    for (const node of routerModuleForRootCalls) {
        if (isRouterModuleForRoot(node) &&
            node.arguments.length >= 2 &&
            (0, typescript_1.isObjectLiteralExpression)(node.arguments[1])) {
            return node;
        }
    }
    return null;
}
function isRouterModuleForRoot(node) {
    // make sure is not an outer call expression (NgModule call)
    const routerModuleForRootIdentifier = (0, tsquery_1.tsquery)(node.expression, 'CallExpression > PropertyAccessExpression > Identifier[name=RouterModule] ~ Identifier[name=forRoot]', { visitAllChildren: true })[0];
    return !!routerModuleForRootIdentifier;
}
function needsMigration(node) {
    return ((0, typescript_1.isStringLiteralLike)(node.initializer) && node.initializer.text === 'enabled');
}
