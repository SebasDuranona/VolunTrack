"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const globs_1 = require("nx/src/utils/globs");
const workspace_context_1 = require("nx/src/utils/workspace-context");
const config_file_1 = require("../utils/config-file");
const DEFAULT_EXTENSIONS = ['ts', 'tsx', 'js', 'jsx', 'html', 'vue'];
exports.createNodes = [
    (0, globs_1.combineGlobPatterns)([
        ...config_file_1.ESLINT_CONFIG_FILENAMES.map((f) => `**/${f}`),
        config_file_1.baseEsLintConfigFile,
        config_file_1.baseEsLintFlatConfigFile,
    ]),
    (configFilePath, options, context) => {
        options = normalizeOptions(options);
        // Ensure that configFiles are set, e2e-run fails due to them being undefined in CI (does not occur locally)
        // TODO(JamesHenry): Further troubleshoot this in CI
        context.configFiles = context.configFiles ?? [];
        // Create a Set of all the directories containing eslint configs
        const eslintRoots = new Set(context.configFiles.map(node_path_1.dirname));
        const configDir = (0, node_path_1.dirname)(configFilePath);
        const childProjectRoots = (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, [
            'project.json',
            'package.json',
            '**/project.json',
            '**/package.json',
        ].map((f) => (0, node_path_1.join)(configDir, f)))
            .map((f) => (0, node_path_1.dirname)(f))
            .filter((childProjectRoot) => {
            // Filter out projects under other eslint configs
            let root = childProjectRoot;
            // Traverse up from the childProjectRoot to either the workspaceRoot or the dir of this config file
            while (root !== (0, node_path_1.dirname)(root) && root !== (0, node_path_1.dirname)(configFilePath)) {
                if (eslintRoots.has(root)) {
                    return false;
                }
                root = (0, node_path_1.dirname)(root);
            }
            return true;
        })
            .filter((dir) => {
            // Ignore project roots where the project does not contain any lintable files
            const lintableFiles = (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, [
                (0, node_path_1.join)(dir, `**/*.{${options.extensions.join(',')}}`),
            ]);
            return lintableFiles.length > 0;
        });
        const uniqueChildProjectRoots = Array.from(new Set(childProjectRoots));
        return {
            projects: getProjectsUsingESLintConfig(configFilePath, uniqueChildProjectRoots, options, context),
        };
    },
];
function getProjectsUsingESLintConfig(configFilePath, childProjectRoots, options, context) {
    const projects = {};
    const rootEslintConfig = context.configFiles.find((f) => f === config_file_1.baseEsLintConfigFile ||
        f === config_file_1.baseEsLintFlatConfigFile ||
        config_file_1.ESLINT_CONFIG_FILENAMES.includes(f));
    // Add a lint target for each child project without an eslint config, with the root level config as an input
    for (const projectRoot of childProjectRoots) {
        // If there's no src folder, it's not a standalone project, do not add the target at all
        const isStandaloneWorkspace = projectRoot === '.' &&
            (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'src')) &&
            (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'package.json'));
        if (projectRoot === '.' && !isStandaloneWorkspace) {
            continue;
        }
        const eslintConfigs = [configFilePath];
        if (rootEslintConfig && !eslintConfigs.includes(rootEslintConfig)) {
            eslintConfigs.unshift(rootEslintConfig);
        }
        projects[projectRoot] = {
            targets: buildEslintTargets(eslintConfigs, projectRoot, options, isStandaloneWorkspace),
        };
    }
    return projects;
}
function buildEslintTargets(eslintConfigs, projectRoot, options, isStandaloneWorkspace = false) {
    const isRootProject = projectRoot === '.';
    const targets = {};
    const targetConfig = {
        command: `eslint ${isRootProject && isStandaloneWorkspace ? './src' : '.'}`,
        cache: true,
        options: {
            cwd: projectRoot,
        },
        inputs: [
            'default',
            // Certain lint rules can be impacted by changes to dependencies
            '^default',
            ...eslintConfigs.map((config) => `{workspaceRoot}/${config}`.replace(`{workspaceRoot}/${projectRoot}`, isRootProject ? '{projectRoot}/' : '{projectRoot}')),
            '{workspaceRoot}/tools/eslint-rules/**/*',
            { externalDependencies: ['eslint'] },
        ],
    };
    if (eslintConfigs.some((config) => (0, config_file_1.isFlatConfig)(config))) {
        targetConfig.options.env = {
            ESLINT_USE_FLAT_CONFIG: 'true',
        };
    }
    targets[options.targetName] = targetConfig;
    return targets;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'lint';
    // Normalize user input for extensions (strip leading . characters)
    if (Array.isArray(options.extensions)) {
        options.extensions = options.extensions.map((f) => f.replace(/^\.+/, ''));
    }
    else {
        options.extensions = DEFAULT_EXTENSIONS;
    }
    return options;
}
